# Intelligent Merge Strategy

Complete algorithm for preserving manual edits when regenerating documentation.

## Core Concepts

**Section Markers:**
```markdown
<!-- AUTO-GENERATED: START -->
[Content regenerated from code analysis]
<!-- AUTO-GENERATED: END -->

<!-- MANUAL-EDIT -->
[User-written content - NEVER overwrite]
<!-- /MANUAL-EDIT -->
```

**Metadata:**
```markdown
<!-- Generated: 2026-01-01 -->
<!-- Source: src/modules/users/ -->
```

## Merge Algorithm

### Step 1: Detect File State

```
IF file does NOT exist:
  â†’ Generate new complete file with AUTO-GENERATED markers
  â†’ Skip to Step 4

IF file exists:
  â†’ Proceed to Step 2
```

### Step 2: Parse Existing File

```typescript
function parseFile(content) {
  const sections = [];
  let currentSection = null;
  let currentContent = [];

  for (const line of content.split('\n')) {
    if (line === '<!-- AUTO-GENERATED: START -->') {
      if (currentSection) sections.push(currentSection);
      currentSection = { type: 'AUTO', content: [] };
    } else if (line === '<!-- AUTO-GENERATED: END -->') {
      if (currentSection) {
        sections.push(currentSection);
        currentSection = null;
      }
    } else if (line === '<!-- MANUAL-EDIT -->') {
      if (currentSection) sections.push(currentSection);
      currentSection = { type: 'MANUAL', content: [] };
    } else if (line === '<!-- /MANUAL-EDIT -->') {
      if (currentSection) {
        sections.push(currentSection);
        currentSection = null;
      }
    } else {
      if (currentSection) {
        currentSection.content.push(line);
      } else {
        // Unmarked content - ask user
        if (!currentSection) {
          currentSection = { type: 'UNKNOWN', content: [] };
        }
        currentSection.content.push(line);
      }
    }
  }

  return sections;
}
```

### Step 3: Merge Sections

```typescript
function mergeSections(parsed, newAutoGenerated) {
  const result = [];

  // Add all MANUAL sections (preserve)
  for (const section of parsed) {
    if (section.type === 'MANUAL') {
      result.push('<!-- MANUAL-EDIT -->');
      result.push(...section.content);
      result.push('<!-- /MANUAL-EDIT -->');
    }
  }

  // Replace AUTO sections with new content
  for (const newSection of newAutoGenerated) {
    result.push('<!-- AUTO-GENERATED: START -->');
    result.push(`<!-- Generated: ${new Date().toISOString().split('T')[0]} -->`);
    result.push(`<!-- Source: ${newSection.source} -->`);
    result.push(...newSection.content);
    result.push('<!-- AUTO-GENERATED: END -->');
  }

  // Handle UNKNOWN sections (no markers)
  for (const section of parsed) {
    if (section.type === 'UNKNOWN') {
      // Ask user
      askUser(`Found unmarked content. Preserve or overwrite?`);
    }
  }

  return result.join('\n');
}
```

### Step 4: Detect Significant Changes

```typescript
function detectChanges(oldAutoSections, newDetection) {
  const changes = {
    newTechnologies: [],
    removedModules: [],
    newPatterns: [],
  };

  // Compare detected stack
  const oldStack = extractStack(oldAutoSections);
  const newStack = newDetection.stack;

  for (const tech of newStack) {
    if (!oldStack.includes(tech)) {
      changes.newTechnologies.push(tech);
    }
  }

  // Compare modules
  const oldModules = extractModules(oldAutoSections);
  const newModules = newDetection.modules;

  for (const module of oldModules) {
    if (!newModules.includes(module)) {
      changes.removedModules.push(module);
    }
  }

  // Compare patterns
  const oldPatterns = extractPatterns(oldAutoSections);
  const newPatterns = newDetection.patterns;

  for (const pattern of newPatterns) {
    if (!oldPatterns.includes(pattern)) {
      changes.newPatterns.push(pattern);
    }
  }

  return changes;
}
```

### Step 5: User Confirmation

```typescript
function showChanges(changes) {
  console.log("## Detected Changes\n");

  if (changes.newTechnologies.length > 0) {
    console.log("### New Technologies");
    for (const tech of changes.newTechnologies) {
      console.log(`+ ${tech}`);
    }
  }

  if (changes.removedModules.length > 0) {
    console.log("\n### Removed Modules");
    for (const module of changes.removedModules) {
      console.log(`- ${module}`);
    }
  }

  if (changes.newPatterns.length > 0) {
    console.log("\n### New Patterns");
    for (const pattern of changes.newPatterns) {
      console.log(`+ ${pattern}`);
    }
  }

  return askUser("Proceed with update?");
}
```

## Merge Scenarios

### Scenario 1: First Generation

```
File: Does NOT exist
Action:
  1. Generate complete file
  2. Wrap all content in AUTO-GENERATED markers
  3. Add metadata (date, source)
  4. Write file
  5. Notify: "âœ“ Generated: [filename]"
```

### Scenario 2: Regeneration - No Manual Edits

```
File: Exists with only AUTO-GENERATED sections
Action:
  1. Parse file
  2. Detect only AUTO sections
  3. Replace with new AUTO-GENERATED content
  4. Write file
  5. Notify: "â†» Updated: [filename] (no manual edits)"
```

### Scenario 3: Regeneration - With Manual Edits

```
File: Exists with MANUAL-EDIT sections
Action:
  1. Parse file
  2. Extract MANUAL sections
  3. Generate new AUTO sections
  4. Merge: new AUTO + preserved MANUAL
  5. Write file
  6. Notify: "â†» Updated: [filename] (preserved N manual sections)"
```

### Scenario 4: Unmarked Content

```
File: Exists with content outside markers
Action:
  1. Parse file
  2. Detect UNKNOWN sections
  3. Ask: "Found unmarked content. [Preserve] [Overwrite] [Cancel]?"
  4. If Preserve: Wrap in MANUAL-EDIT
  5. If Overwrite: Replace with AUTO-GENERATED
  6. If Cancel: Skip this file
```

### Scenario 5: Structural Conflict

```
File: New structure incompatible with old
Action:
  1. Create backup: [filename].backup
  2. Show user:
     "Structure changed significantly.
      Backup: [filename].backup
      [Regenerate from scratch] [Manual merge] [Cancel]"
  3. If Regenerate: Generate new, link to backup
  4. If Manual merge: Keep old, create new as [filename].new
  5. If Cancel: Skip this file
```

## Special File Handling

### CLAUDE.MD

```
First generation:
  â†’ Generate complete with AUTO-GENERATED markers

Regeneration:
  â†’ ALWAYS ask before changes:
     "CLAUDE.MD contains business context.
      [A] Update stack/structure only
      [B] Regenerate complete
      [C] Cancel"

  Option A:
    â†’ Preserve all business sections
    â†’ Update only technical stack
    â†’ Update architecture overview

  Option B:
    â†’ Create CLAUDE.MD.backup
    â†’ Regenerate from code + new user answers

  Option C:
    â†’ Skip CLAUDE.MD, continue with other files
```

### architecture.md

```
Regeneration:
  â†’ Mark folder structure as AUTO-GENERATED
  â†’ Preserve notes/comments as MANUAL-EDIT
  â†’ If structure changed:
     - Show diff:
       + New folders
       - Removed folders
       ~ Modified purposes
     - Ask: "Update architecture.md with changes?"
```

### SOPs

```
Regeneration:
  â†’ If canonical example changed:
     - Update code snippets automatically
     - Keep checklist structure
     - Notify: "Updated [sop] with new example from [path]"

  â†’ If manually added steps exist:
     - Preserve MANUAL-EDIT steps
     - Update AUTO-GENERATED examples
     - Merge both
```

## Notification Format

```
Generate/Update summary:

âœ“ Generated:   [filename] (new)
â†» Updated:     [filename] (preserved N edits)
âš  Conflict:    [filename] (requires decision)
- No changes:  [filename] (code unchanged)
ðŸ’¾ Backup:     [filename].backup (created)
```

## Change Preview

```markdown
Before writing files, show:

## Files to Modify

### New Files (3)
- .claude/rules/backend/jobs.md (Bull Queue detected)
- .claude/rules/frontend/forms.md (react-hook-form detected)
- .claude/rules/sop/adding-background-job.md (from jobs pattern)

### Updated Files (2)
- .claude/rules/backend/api-endpoints.md
  ~ New example from src/modules/products/
  âœ“ Preserves 1 manual section

- .claude/rules/architecture.md
  + Added: src/jobs/ folder
  âœ“ Preserves directory purpose notes

### No Changes (4)
- .claude/rules/backend/security.md (no changes in guards/)
- .claude/rules/frontend/components.md (shadcn/ui unchanged)
- .claude/rules/testing.md (test patterns unchanged)
- .claude/rules/general.md (commands unchanged)

Proceed with update? [Y/n]
```

## Error Handling

### Parse Error

```
IF cannot parse markers:
  â†’ Warn: "Could not parse [filename]. Markers may be malformed."
  â†’ Options:
     [A] Regenerate from scratch (backup first)
     [B] Skip this file
     [C] Cancel all updates
```

### Write Error

```
IF cannot write file:
  â†’ Error: "Failed to write [filename]: [reason]"
  â†’ Keep changes in memory
  â†’ Ask: "Retry? [Y/n]"
```

### Conflict Resolution

```
IF cannot auto-merge:
  â†’ Create [filename].new with new content
  â†’ Create [filename].conflict with conflict markers
  â†’ Notify: "Conflict in [filename]. Created:
             - [filename].new (new content)
             - [filename].conflict (diff)
             Review and merge manually."
```

## Testing Merge Strategy

**Test cases to verify:**

1. **New file generation**
   - Creates file with markers
   - Includes metadata
   - âœ“ Pass if file has AUTO-GENERATED markers

2. **Regeneration without edits**
   - Replaces AUTO sections
   - Preserves structure
   - âœ“ Pass if content updated, no manual sections lost

3. **Regeneration with edits**
   - Preserves MANUAL sections
   - Updates AUTO sections
   - âœ“ Pass if manual content intact, auto content new

4. **Unmarked content handling**
   - Detects UNKNOWN sections
   - Asks user for action
   - âœ“ Pass if user prompted, choice respected

5. **Structural conflict**
   - Creates backup
   - Offers options
   - âœ“ Pass if backup exists, user chooses outcome

6. **Change detection**
   - Identifies new technologies
   - Identifies removed modules
   - Shows diff preview
   - âœ“ Pass if changes listed correctly

## Implementation Checklist

When implementing merge:

- [ ] Parse existing file for markers
- [ ] Identify AUTO vs MANUAL sections
- [ ] Extract metadata (date, source) from AUTO sections
- [ ] Detect code changes (new tech, removed modules)
- [ ] Show change preview to user
- [ ] Generate new AUTO sections from code
- [ ] Preserve all MANUAL sections
- [ ] Handle UNKNOWN sections (ask user)
- [ ] Merge sections in correct order
- [ ] Add updated metadata
- [ ] Create backup if major changes
- [ ] Write merged content
- [ ] Show notification summary
